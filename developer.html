<!DOCTYPE html>
<html>
  <head>
    <title>Flatpak</title>
    <meta content='text/html; charset=UTF8' http-equiv='content-type'>
    <meta content='fixme' name='description'>
    <meta content='fixme' name='keywords'>
    <meta content='width=device-width,initial-scale=1' name='viewport'>
    <link href='/images/icons/favicon.png' rel='icon' type='image/png'>
    <link href='/favicon.ico' rel='shortcut icon' type='image/x-icon'>
    <link href="stylesheets/site.css" rel="stylesheet" />
    <link href="/stylesheets/_animate.css" rel="stylesheet" />
    <link href="http://overpass-30e2.kxcdn.com/overpass.css" rel="stylesheet" />
  </head>
  <body id='page-top'>
    <nav class='navbar navbar-default navbar-fixed-top' id='mainNav'>
      <div class='container-fluid'>
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class='navbar-header'>
          <button class='navbar-toggle collapsed' data-target='#bs-example-navbar-collapse-1' data-toggle='collapse' type='button'>
            <span class='sr-only'>Toggle navigation</span>
            <span class='icon-bar'></span>
            <span class='icon-bar'></span>
            <span class='icon-bar'></span>
          </button>
          <a class='navbar-brand page-scroll' href='index.html'>Flatpak</a>
        </div>
        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class='collapse navbar-collapse' id='bs-example-navbar-collapse-1'>
          <ul class='nav navbar-nav navbar-right'>
            <li>
              <a class='page-scroll' href='index.html#about'>About</a>
            </li>
            <li>
              <a class='page-scroll' href='index.html#users'>Users</a>
            </li>
            <li>
              <a class='page-scroll' href='index.html#developers'>Developers</a>
            </li>
            <li>
              <a class='page-scroll' href='index.html#contributions'>Contributions</a>
            </li>
          </ul>
        </div>
        <!-- /.navbar-collapse -->
      </div>
      <!-- /.container-fluid -->
    </nav>
  </body>
  <div class='container'>
    <div class='row'>
      <div class='col-lq-12'>
        <a name='building-complex'></a>
        <h2>Building a Complex Application</h2>
        <p>
          In this part we will build a more complex application, using the basic xdg-app tools.
        </p>
        <p>
          We'll choose to build the gnome dictionary application, because its a small
          app with no dependencies.
          To build it we use the SDK (software development kit) that matches the runtime we used in the previous part.
          The SDK contains the development toolchain and the headers needed to build applications using the libraries in the runtime.
        </p>
        <p>
          First we need to install the SDK.
          This is rather large, so it may take a while:
        </p>
        <pre>xdg-app --user install gnome-nightly org.gnome.Sdk</pre>
        <p>
          We also want the sources to the application we want to build:
        </p>
        <pre>wget https://download.gnome.org/sources/gnome-dictionary/3.19/gnome-dictionary-3.19.90.tar.xz</pre>
        <p>
          Just like last time we start by creating the application directory where the application will be installed.
          However, this time we use the
          <em>build-init</em>
          command to create it:
        </p>
        <pre>xdg-app build-init appdir2 org.gnome.Dictionary org.gnome.Sdk org.gnome.Platform</pre>
        <p>
          This creates a directory called "appdir2" with a metadata file and the right directory structure.
          The only difference from last time is that the metadata file specifies a sdk as well as a runtime.
          A sdk is really just a runtime, but it is used during the build phase,
          rather than when the user runs the app.
        </p>
        <p>
          Now that we have specified a sdk we can use the xdg-app
          <em>build</em>
          command.
          This is very similar to the
          <em>run</em>
          command, except it operates on an application build directory rather than an installed application, and it uses the sdk instead of the regular runtime.
          It also gives the sandbox access to all your files.
          For example, you can run:
        </p>
        <pre>$ xdg-app build appdir2 touch /app/some_file&#x000A;$ xdg-app build appdir2 ls -l /app&#x000A;total 0&#x000A;-rw-r--r-- 1 alex wheel 0 Feb 19 16:03 some_file</pre>
        <p>
          This will have created a file
          <code>appdir2/files/some_file</code>
          in your tutorial directory.
        </p>
        <p>
          Using this command you can build the application like you normally would, except in a sandbox.
          Since it is in a sandbox it will automatically use the compiler and other tools from the sdk.
          gnome-dictionary builds fine with a traditional configure; make; make install; incantation, so we only have to add a xdg-app prefix to these:
        </p>
        <pre>tar xvf gnome-dictionary-3.19.90.tar.xz&#x000A;cd gnome-dictionary-3.19.90/&#x000A;xdg-app build ../appdir2 ./configure --prefix=/app&#x000A;xdg-app build ../appdir2 make&#x000A;xdg-app build ../appdir2 make install&#x000A;cd ..</pre>
        <p>
          We also need to give the app access to X11 and the network, and specify the
          command that is used to start the app.
          This is done with the build-finish operation:
        </p>
        <pre>  xdg-app build-finish appdir2 --socket=x11 --share=network --command=gnome-dictionary</pre>
        <p>
          This adds some extra info to the metadata file, and creates the exports directory,
          which we'll come back to later.
          You can install and try the app by running
        </p>
        <pre>xdg-app build-export repo appdir2&#x000A;xdg-app --user install tutorial-repo org.gnome.Dictionary&#x000A;xdg-app run org.gnome.Dictionary</pre>
        <p>
          You will see some warnings because we didn't grant the app access to the dconf
          database, but other than that everything works.
        </p>
        <p>
          On interesting new thing here is the exports mentioned above.
          If you look into the appdir2/export/ directory you will find this structure:
        </p>
        <pre>appdir2/export&#x000A;└── share&#x000A;    ├── applications&#x000A;    │   └── org.gnome.Dictionary.desktop&#x000A;    └── dbus-1&#x000A;        └── services&#x000A;            └── org.gnome.Dictionary.service</pre>
        <p>
          And when the app is installed, these files will be exported into ~/.local/share/xdg-app/exports/.
          The xdg-app package then sets the
          <code>XDG_DATA_DIRS</code>
          environment variable to point to this directory, which means your desktop environment will look in it.
          This sounds a bit complicated, but what it means is that once the app is
          installed it will automatically appear among the normal applications in your desktop environment.
        </p>
        <p>
          There is one limit on what gets exported though.
          All the filesnames (not directory names) must have the application id as a prefix.
          This works in the above setup because the desktop file is org.gnome.Dictionary.desktop, which is what we used for the id.
          This limitation guarantees that applications cannot cause conflicts, and that they can't override any system installed applications.
        </p>
        <p>
          We have now built a simple application with no dependencies.
          If there are any dependencies that are not in the runtime you need to build those too.
          This means more cycles of configure; make; make install; While this is not hard, it is a lot of manual repeated work.
        </p>
        <a name='automating'></a>
        <h2>
          Automating using the
          <code>xdg-app-builder</code>
          tool
        </h2>
        <p>
          However, if you look closely at the commands we used you will set not much what we did was specific to this application.
          In fact, the only things related to gnome-dictionary are the:
        </p>
        <ul>
          <li>Application id</li>
          <li>Source url</li>
          <li>Binary name</li>
          <li>Necessary permissions</li>
        </ul>
        <p>
          It turns out that most open source applications are built in very similar ways.
          One can even consider this an
          <a href='https://github.com/cgwalters/build-api'>API</a>
          for building modules.
          And if some module does not conform to this API, then it is easy to change the upstream to conform, or if upstream is not interested, apply a local patch.
        </p>
        <p>
          The xdg-app-builder tool that ships with xdg-app is based on this idea.
          You describe your application, and the modules you want to build into it, and then xdg-app-builder takes care of calling the lower-level xdg-app build commands for you.
        </p>
        <p>
          The equivalent of what we did in part 2 is this json:
        </p>
        <pre>{&#x000A;  "app-id": "org.gnome.Dictionary",&#x000A;  "runtime": "org.gnome.Platform",&#x000A;  "runtime-version": "master",&#x000A;  "sdk": "org.gnome.Sdk",&#x000A;  "command": "gnome-dictionary",&#x000A;  "finish-args": [&#x000A;     "--socket=x11",&#x000A;     "--share=network"&#x000A;  ],&#x000A;  "modules": [&#x000A;    {&#x000A;      "name": "gnome-dictionary",&#x000A;      "sources": [&#x000A;        {&#x000A;          "type": "archive",&#x000A;          "url": "https://download.gnome.org/sources/gnome-dictionary/3.19/gnome-dictionary-3.19.90.tar.xz",&#x000A;          "sha256": "c719333d77b8c1dffc46baab2402bad565bd949440b5b625d758047a98493418"&#x000A;        }&#x000A;      ]&#x000A;    }&#x000A;  ]&#x000A;}</pre>
        <p>
          If you put this in a file called
          <code>org.gnome.Dictionary.json</code>
          you can =
          build and export the app using:
        </p>
        <pre>$ xdg-app-builder --repo=repo appdir3 org.gnome.Dictionary.json</pre>
        <p>
          And to test this you use:
        </p>
        <pre>$ xdg-app --user update org.gnome.Dictionary&#x000A;$ xdg-app run org.gnome.Dictionary</pre>
        <p>
          So the above commands downloaded the files, initialized the build dir, built the modules, finished the app and exported it to the repo.
          Just like we did before.
        </p>
        <p>
          However, even for this simple file it did a lot of other nice things too.
        </p>
        <p></p>
        <ul>
          <li>It verified the sha256 checksum of the downloaded tarball</li>
          <li>It built all sources in a fixed location (in /run/build) to ensure more repeatable builds.</li>
          <li>
            It ran the builds without access to any part of the host filesystem, other than the directory with the extracted sources.
            This means less chance of the build machine details affecting the build.
          </li>
          <li>It automatically extracted all the debug information from the installed binaries into separate files, and these were commited to a separately installable runtime called org.gnome.Dictionary.Debug.</li>
          <li>
            Translations were also extracted to separately installable runtimes called
            <code>org.gnome.Dictionary.Locale.
            <em>$lang</em></code>
          </li>
          <li>It cached each stage of the build, so that if you need to rebuild the app only the modules that have changed will be rebuilt.</li>
        </ul>
        <p>
          Other than this xdg-app-builder has a lot of useful features.
          The obvious one is that you can build multiple modules into the application, and you can have multiple sources for each module.
          Sources can be of several types.
          Currently it supports: archive (.tar, .zip), git, bzr, patch files, and just running shell commands.
        </p>
        <p>
          There is also a cleanup phase that happens after the build.
          This phase lets you remove things that was added during the build, that will not be needed during runtime.
          For instance, you can remove headers, development docs and similar things here.
          xdg-app-builder supports two properties for this.
          First a list of filename patterns, and secondly a list of commands to run during the cleanup phase.
        </p>
        <pre>"cleanup": [ "/include", "/bin/foo-*", "*.a" ]&#x000A;"cleanup-commands": [ "sed s/foo/bar/ /bin/app.sh" ]</pre>
        <p>
          Additionally, the cleanup property can be set on a per-module basis, and will
          then only match filenames that were created by that particular module.
        </p>
        <p>
          Another special feature is the
          <em>rename-icon</em>,
          <em>rename-desktop-file</em>
          and re
          <em>name-appdata</em>
          properties which lets you rename these kinds of files to match the application id.
          You have to do this because upstream files don't use the application id in the name, which is not allowed by xdg-app during export.
        </p>
        <p>
          The nightly build of the gnome applications all are built using xdg-app-builder, and you can get a lot of example json files
          <a href='https://github.com/alexlarsson/gnome-apps-nightly'>there,</a>
          for instance a complete version of
          <a href='https://github.com/alexlarsson/gnome-apps-nightly/blob/master/org.gnome.Dictionary.json'>gnome-dictionary built from git</a>.
          <a href='https://github.com/alexlarsson/nightly-build-apps'>here</a>.
        </p>
        <p>
          For detailed documentations on all xdg-app-builder properties.
          See the man page for xdg-app builder.
        </p>
        <a name='sandbox'></a>
        <h2>The xdg-app Sandbox</h2>
        <p>
          In the first section we created a very small application.
          All it did was print to stdout and would be very easy to sandbox.
          In fact, since we didn't specify any permissions for it this application already runs in a very tight sandbox.
        </p>
        <p>
          Here is what the sandbox does:
        </p>
        <ul>
          <li>No access to any host files except the runtime, the app, and ~/.var/app/org.test.Hello,  and only the last of these  is writable.</li>
          <li>/tmp is unique to the application instance.</li>
          <li>setuid functionallity is disabled.</li>
          <li>
            Processes are in a cgroup which they cannot get out of.
            This lets you know what application a process is running in, in an unfakable way.
            (This will be very important later for per-application preferences.)
          </li>
          <li>No access to the network.</li>
          <li>No access to any device nodes (apart from /dev/null, etc).</li>
          <li>Can't see any processes outside the sandbox.</li>
          <li>
            A set of seccomp rules are loaded that limits what syscalls the app can do.
            For instance, it can't use nonstandard network socket types, or ptrace other processes.
          </li>
          <li>Limited access to the session dbus instance, is only allowed  to own its own name on the bus and can't talk to anyone else.</li>
          <li>No access to host services like X, system dbus, or pulseaudio.</li>
        </ul>
        <p>
          Of course, its very easy to secure a Hello world program, as it doesn't need to do anything.
          There are designs (and experimental code) to allow applications to securely break out of the sandbox (using something called
          <em>Portals</em>).
        </p>
        <p>
          We saw this already where we used this command, granting X11 and network access:
        </p>
        <pre>  xdg-app build-finish appdir2 --socket=x11 --share=network --command=gnome-dictionary</pre>
        <p>
          These arguments translate to these properties in the application metadata file:
        </p>
        <pre>[Application]&#x000A;name=org.gnome.Dictionary&#x000A;runtime=org.gnome.Platform/x86_64/master&#x000A;sdk=org.gnome.Sdk/x86_64/master&#x000A;command=gnome-dictionary&#x000A;&#x000A;[Context]&#x000A;shared=network;&#x000A;sockets=x11;</pre>
        <p>
          As we gave no access to the filesystem in the above the resulting app can't see your files.
          We can verify this with a command like:
        </p>
        <pre>$ xdg-app run --command=ls org.gnome.Dictionary ~/&#x000A;<nothing></pre>
        <p>
          The permissions in the metadata file are only the default values though.
          You can override these in different ways.
          First of all, xdg-app run takes the same command line arguments as build-finish, which can override permissions for that instance.
          For example, this will let it see your home directory:
        </p>
        <pre>$ xdg-app run --filesystem=home --command=ls org.gnome.Dictionary ~/&#x000A;<homedir listing...></pre>
        <p>
          You can also permanently override permissions for an application:
        </p>
        <pre>$ xdg-app --user override --filesystem=home org.gnome.Dictionary&#x000A;$ xdg-app run --command=ls org.gnome.Dictionary ~/&#x000A;<homedir listing...></pre>
        <p>
          This can then again be overridden in a specific instance:
        </p>
        <pre>$ xdg-app run --nofilesystem=home --command=ls org.gnome.Dictionary ~/&#x000A;<nothing></pre>
        There are quite a few options that control sandbox permissions.
        So, I'm going to list some useful examples of what can be done.
        (Note that all options have a negative version too, i.e.
        --unshare undoes --share.)
        <p>
          Grant access to some of your files:
        </p>
        <pre>  --filesystem=host    # All files&#x000A;  --filesystem=home    # Your homedirectory&#x000A;  --filesystem=home:ro # Your homedirectory, read-only&#x000A;  --filesystem=/some/dir --filesystem=~/other/dir # paths&#x000A;  --filesystem=xdg-download # The XDG Download directory&#x000A;  --nofilesystem=...&#x000A;  # Undo some of the above</pre>
        <p>
          Allow the application to show windows using X11:
        </p>
        <pre>--socket=x11 --share=ipc</pre>
        <p>
          <em>
            Note: --share=ipc means that the sandbox shares ipc namespace with the host.
            This is not necessarily required, but without it the X shared memory extension will not work, which is very bad for X performance.
          </em>
        </p>
        <p>
          Allow OpenGL rendering:
        </p>
        <pre>--device=dri</pre>
        Allow the application to show windows using wayland:
        <pre>--socket=wayland</pre>
        Let the application play sounds using pulseaudio:
        <pre>--socket=pulseaudio</pre>
        <p>
          Let the application access the network:
        </p>
        <pre> --share=network</pre>
        <p>
          <em>
            Note: Giving network access also grants access to all host services listening on abstract unix sockets (due to how network namespaces work), and these have no permission checks.
            This unfortunately affects e.g.
            the X server and the session bus which listens to abstract sockets by default.
            A secure distribution should disable these and just use regular sockets.
          </em>
        </p>
        <p>
          Let the application talk to a named service on the session bus:
        </p>
        <pre>--talk-name=org.freedesktop.secrets</pre>
        <p>
          Let the application talk to a named service on the system bus:
        </p>
        <pre> --system-talk-name=org.freedesktop.GeoClue2</pre>
        <p>
          Give the application unlimited access to all of dbus:
        </p>
        <pre> --socket=system-bus --socket=session-bus</pre>
      </div>
    </div>
  </div>
  <script src="javascripts/jquery.js"></script>
  <script src="javascripts/jquery.easing.min.js"></script>
  <script src="javascripts/all.js"></script>
  <script src="javascripts/bootstrap.js"></script>
</html>
<script>
  
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-68811788-1']);
  _gaq.push(['_trackPageview']);
  
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
